/*
	Leon is WebGL-accelerated mpeg1-like video decoder

	Copyright (c) 2014-2022 Anton Bilan, Easy Bits Limited
	https://www.easy-bits.com
	JSV is a registered trademark of Easy Bits Limited

	Anyone can use and modify this software for free for non-commercial 
	use only provided they keep this license notice and say out loud word Leon.
	For commercial use obtaining a different license is required.

	This software is distributed WITHOUT ANY WARRANTY;
	even the implied warranty of MERCHANTABILITY or FITNESS FOR 
	A PARTICULAR PURPOSE.

*/

var CONV_INT="float _s(vec2 v) {\nfloat _ap = v.r*255. + v.g*255.*256.;\nif(_ap > 32767.)\n{\n_ap -= 65536.;\n}\nreturn _ap;\n}\nfloat _E(vec2 v) {\nfloat _ap;\nif( v.g < .5 ){\n_ap = v.r*255. + v.g*255.*256.;\n} else {\n_ap = (v.r*255.-256.) + (v.g*255. - 255.)*256.;\n}\nreturn _ap;\n}\nvec2 _B(float _aw){\nif(_aw < 0.){\n_aw += 65536.;\n}\nfloat _al = floor( _aw / 256. );\nfloat _ao = _aw - _al*256.;\nreturn vec2(_ao / 255., _al / 255. );\n}",CONV_FLOAT="float _s(vec3 v) {\nfloat _ap = v.r*255. + v.g*255.*256.;\nif(_ap > 32767.)\n{\n_ap -= 65536.;\n}\nreturn _ap;\n}\nfloat _E(vec2 v) {\nfloat _ap;\nif( v.g < .5 ){\n_ap = v.r*255. + v.g*255.*256.;\n} else {\n_ap = (v.r*255.-256.) + (v.g*255. - 255.)*256.;\n}\nreturn _ap;\n}\nconst float _an = 1./255.;\nvec2 normalize_after_multi( vec2 v ){\nfloat v0abs = abs( v.r );\nif( v0abs > 1. ){\nfloat _ai = sign(v.r);\nfloat low = floor( v0abs / _an + .5 );\nfloat new_low = low - 256.*floor(low/256.);\nv.r = _ai * new_low * _an;\nv.g += _ai * ( low - new_low ) / 256. * _an;\n}\nreturn v;\n}\nvec2 _Y(vec2 v, float n){\nfloat d = _an * n;\nfloat v0 = floor( v[0] / d );\nfloat v1 = floor( v[1] * 256. / d ) / 256.;\nreturn vec2( v0*_an, v1*_an );\n}\nvec2 _D( vec2 _aq ){\nif( _aq.g < 0.5 ){\nreturn _aq;\n}else{\nreturn vec2( -(1.-( _aq.r - _an) ) + floor(1. - _aq.r)*(1.+_an), -(1.- (_aq.g-floor( 1.- _aq.r ) * _an ) ) );\n}\n}\nvec2 _x( vec2 _aq ){\nif(abs( _aq.r) > 1.){\n_aq = normalize_after_multi( _aq );\n}\nif( _aq.r < 0. || _aq.g < 0. ){\nfloat abs0 = abs( _aq.r );\nif( abs0 == 0. ){\nreturn vec2( 0., 1.+_aq.g + _an );\n} else {\nreturn vec2( 1.-abs0+_an, 1.+_aq.g );\n}\n}\nreturn _aq;\n}\nvec2 _ab( vec2 _aq[8], float x ){\nfloat _as, _at;\nvec2 _az;\n_az = vec2(0.,0.);\n_at = 3.1415926535897932384626433832795;\n_as = 1./sqrt(2.);\n_az += (_as/2.)*_aq[0];\n_as = 1.;\nfor( int u=1;u<8;u++){\n_az += (_as/2.)*_aq[u]*cos((2.*x+1.)*float(u)*_at/16.);\n}\nreturn _az;\n}",
COLUMNS_0="precision mediump float;\nprecision mediump int;\nuniform sampler2D _G;\nuniform sampler2D _f;\nuniform sampler2D _t;\nuniform sampler2D _b;\nuniform sampler2D _w;\nuniform sampler2D _v;\nuniform sampler2D _c;\nvarying vec2 _S;\nuniform int _ad;\nuniform int _ae;",COLUMNS_1="void main() {\nint b1, b3, b4, b6, b7, tmp1, tmp2, m0, x0, x1, x2, x3, x4, y3, y4, y5, y6, y7;\nvec2 _aj, _ah;\nfloat _A, _z;\nfloat _q;\nfloat _Q, _R;",COLUMNS_INT_1="float _X[8];",COLUMNS_FLOAT_1="vec2 _X[8];",COLUMNS_2=
"float _y = 0.4;\nfloat _m, _l;\nfloat _o, _k;\nfloat _e, _g;\nfloat _d, _h;\n_h = 1.0 / ( float(_ae) / 8. );\n_d = 1.0 / ( float(_ad) / 8. );\n_o = 1.0 / float(_ad);\n_k = 1.0 / float(_ae);\n_g = 2.* _k;\n_e = _o;\n_Q = \tfloor( floor( _S.x / _k ) / 8.0 );\n_R = \tfloor( floor( _S.y / _o ) / 8.0 );\n_A = mod( floor( _S.x / _g ), 4.0 );\n_z = mod( floor( _S.y / _e ), 8.0 );\n_m = _Q * 8. * _k + _z * _k + _k / 2.;\n_l = _R * 8. * _o + _o / 2.;\nfor( int i = 0; i < 8; i++ )\n{",COL_INT_2="_X[i] = _E( texture2D( _G, vec2( _m , _l + _o * float(i) ) ).ra );",
COL_FLOAT_2="_X[i] = _D( texture2D( _G, vec2( _m , _l + _o * float(i) ) ).ra );",COL_3="}\nint _ag = texture2D( _w, vec2( ( _Q + .5 ) * _h, ( _R + .5 ) * _d ) ).r > 0. ? 1 : 0;\nfloat _O;\n_q = floor( texture2D( _t, vec2( _Q * _h, _R * _d ) )[0] * 255. + 0.5 );",COL_INT_21="float dc = _X[0];",COL_FLOAT_21="vec2 dc = _X[0];",COL_31="for( int i = 0; i < 8; i++ )\n{",COL_INT_22="if( _X[i] == 0. )",COL_FLOAT_22="if( _X[i] == vec2(0., 0.) )",COL_32="{\nfloat _U = texture2D( _v, vec2( 0.075 + _z * 0.125, 0.075 + float(i) * 0.125 ) ).r;\nfloat last_non_zero = texture2D( _c, vec2( _Q * _h, _R * _d ) ).r;\nif( _U  + 1.> last_non_zero ){\ncontinue;\n}\n}\n_X[i] *= 2.;\nfloat texelcoord_Q_x = 0.075 + _z * 0.125;\nfloat texelcoord_Q_y = 0.075 + float( i ) * 0.125;\nfloat _j = texelcoord_Q_y / 2.;\nif( _ag ==  0){\n_j += .5;\n}\n_O = floor( texture2D( _f, vec2( texelcoord_Q_x, _j ) )[0] * 255. + 0.5 );",
COL_INT_3="if (_ag == 0){\n_X[i] += _X[i] < 0. ? -1. : 1.;\n}\n_X[i] = floor(  _X[i] * _q * _O  / 16.0 );\nif( mod( _X[i], 2. ) == 0. )\n{\n_X[i] -= ( _X[i] > 0. ) ? 1. : -1.;\n}\n_X[i] = min( _X[i], 2047. );\n_X[i] = max( _X[i], -2048. );\n_X[i] *= floor( texture2D( _b, vec2( texelcoord_Q_x, texelcoord_Q_y ) )[0] * 255. + 0.5 );",COL_FLOAT_3="if (_ag == 0){\n_X[i].r += dot( _X[i], vec2( 1., 256.)) < 0. ? -_an : _an;\n}\n_X[i] =  _Y( _X[i] * _q * _O, 16.0 );\nif( mod( floor( _X[i].r / _an ), 2. ) == 0. ){\n_X[i].r -= dot( _X[i], vec2( 1., 256.)) < 0. ? _an : -_an;\n}\nif( dot( _X[i], vec2( 1., 256.)) > 8.027 ){\n_X[i] = vec2( 1., 7.*_an);\n}\nif( dot( _X[i], vec2( 1., 256.)) < -8.031 ){\n_X[i] = vec2( 0., -8.*_an);\n}",
COL_4="}\nif ( _z == 0.0 && _ag == 1 )\n{",COL_INT_31="_X[0] = dc * 256.;",COL_FLOAT_31="_X[0] = dc * 8.;",COL_41="}",COL_INT_5="b1 = int(_X[4]);\nb3 = int(_X[2]) + int(_X[6]);\nb4 = int(_X[5]) - int(_X[3]);\ntmp1 = int(_X[1]) + int(_X[7]);\ntmp2 = int(_X[3]) + int(_X[5]);\nb6 = int(_X[1]) - int(_X[7]);\nb7 = tmp1 + tmp2;\nm0 =  int(_X[0]);\nx4 =  ((b6*473 - b4*196 + 128) / 256) - b7;\nx0 =  x4 - (((tmp1 - tmp2)*362 + 128) / 256);\nx1 =  m0 - b1;\nx2 =  (((int(_X[2]) - int(_X[6]))*362 + 128) / 256) - b3;\nx3 =  m0 + b1;\ny3 =  x1 + x2;\ny4 =  x3 + b3;\ny5 =  x1 - x2;\ny6 =  x3 - b3;\ny7 = -x0 - ((b4*473 + b6*196 + 128) / 256);\nif( _A == 0.0 )\n{\n_aj = _B( floor( float( b7 + y4 ) * _y ) );\n_ah = _B( floor( float( x4 + y3 ) * _y ) );\n}\nelse if( _A == 1.0 )\n{\n_aj = _B( floor( float ( y5 - x0 ) * _y ) );\n_ah = _B( floor( float ( y6 - y7 ) * _y ) );\n}\nelse if( _A == 2.0 )\n{\n_aj = _B( floor( float ( y6 + y7 ) * _y ) );\n_ah = _B( floor( float ( x0 + y5 ) * _y ) );\n}\nelse\n{\n_aj = _B( floor( float ( y3 - x4 ) * _y ) );\n_ah = _B( floor( float ( y4 - b7 ) * _y ) );\n}",
COL_FLOAT_5="if( _A == 0.0 )\n{\n_aj = _x( _ab( _X, 0.) * _y );\n_ah = _x( _ab( _X, 1.) * _y );\n}\nelse if( _A == 1.0 )\n{\n_aj = _x( _ab( _X, 2.) * _y );\n_ah = _x( _ab( _X, 3.) * _y );\n}\nelse if( _A == 2.0 )\n{\n_aj = _x( _ab( _X, 4.) * _y );\n_ah = _x( _ab( _X, 5.) * _y );\n}\nelse\n{\n_aj = _x( _ab( _X, 6.) * _y );\n_ah = _x( _ab( _X, 7.) * _y );\n}",COL_5="gl_FragColor = vec4(\n_aj.r,\n_aj.g,\n_ah.r,\n_ah.g\n);\n}",SHADER_FRAGMENT_IDCT_ROWS_COM="precision mediump float;\nuniform sampler2D _G;\nuniform sampler2D _i;\nuniform sampler2D _w;\nuniform sampler2D _I;\nvarying vec2 _S;\nuniform int _ad;\nuniform int _ae;\nuniform float _ac;\nfloat _g, _e;\nfloat _F( float _ay ){\nreturn sign( _ay ) * floor( abs( _ay ) );\n}\nvec4 _p( float _ax, float _ay ) {\nvec4 _C;\nfloat _u = sign( _ax ) * floor( abs(_ax) / 4. );\nfloat _n = mod( abs(_ax), 4. );\nvec4 _Z = texture2D( _i, vec2( _S.x + _u * _g, 1.  - _S.y - _ay * _e ));\nvec4 _H;\nif( _n == 0. )\n{\n_C = _Z;\n}\nelse if( _ax > 0. )\n{\n_H = texture2D( _i, vec2( _S.x + ( _u + 1. ) * _g, 1. - _S.y - _ay * _e ));\nif( _n == 1. )\n{\n_C[0] = _Z[1];\n_C[1] = _Z[2];\n_C[2] = _Z[3];\n_C[3] = _H[0];\n}\nelse if( _n == 2. )\n{\n_C[0] = _Z[2];\n_C[1] = _Z[3];\n_C[2] = _H[0];\n_C[3] = _H[1];\n}\nelse\n{\n_C[0] = _Z[3];\n_C[1] = _H[0];\n_C[2] = _H[1];\n_C[3] = _H[2];\n}\n}\nelse\n{\n_H = texture2D( _i, vec2( _S.x + ( _u - 1. ) * _g, 1. - _S.y - _ay  * _e ));\nif( _n == 3. )\n{\n_C[0] = _H[1];\n_C[1] = _H[2];\n_C[2] = _H[3];\n_C[3] = _Z[0];\n}\nelse if( _n == 2. )\n{\n_C[0] = _H[2];\n_C[1] = _H[3];\n_C[2] = _Z[0];\n_C[3] = _Z[1];\n}\nelse\n{\n_C[0] = _H[3];\n_C[1] = _Z[0];\n_C[2] = _Z[1];\n_C[3] = _Z[2];\n}\n}\nreturn _C;\n}",
ROWS_COM_1="float _y = 0.4;\nvoid main() {\nint b1, b3, b4, b6, b7, tmp1, tmp2, m0, x0, x1, x2, x3, x4, y3, y4, y5, y6, y7;\nfloat _a;\nfloat _o, _k, _Q, _R, _A, _z, _m, _l;\nfloat _d, _h;",DCT_COEF_DECL_INT="int _X[8];",DCT_COEF_DECL_FLOAT="vec2 _X[8];",ROWS_COMM_2="_o = 1.0 / float(_ad);\n_k = 1.0 / float(_ae);\n_g = 2. * _k;\n_e = _o;\n_h = 1.0 / ( float(_ae) / 4. );\n_d = 1.0 / ( float(_ad) / 8. );\n_Q = \tfloor( floor( _S.x / _g ) / 2.0 );\n_R = \tfloor( floor( _S.y / _e ) / 8.0 );\n_A = mod( floor( _S.x / _g ), 2.0 );\n_a = 7. - mod( floor( _S.y / _e ), 8.0 );\n_z = mod( floor( _S.y / _e ), 8.0 );\n_m = _Q * 4. * _k + floor( _a / 2. ) * _k + _k * .5;\n_l = ( _R + .95 ) * 8. * _o;\nif( mod( _a, 2. ) == 0.0 )\n{\nfor( int i = 0; i < 8; i++ )\n{\nvec4 texel = texture2D( _G, vec2( _m , _l - _o * float(i) ) );",
ROWS_INT1="_X[i] = int( _E( vec2( texel[0], texel[1] ) ) / _y );",ROWS_FLOAT1="_X[i] = _D( vec2( texel[0], texel[1] ) ) / _y;",ROWSCOM22="}\n}\nelse\n{\nfor( int i = 0; i < 8; i++ )\n{\nvec4 texel = texture2D( _G, vec2( _m , _l - _o * float(i) ) );",ROWS_INT2="_X[i] = int( _E( vec2( texel[2], texel[3] ) ) / _y );",ROWS_FLOAT2="_X[i] = _D( vec2( texel[2], texel[3] ) ) / _y;",ROWS_COM3="}\n}",ROWSCOM_INT4="b1 = _X[4];\nb3 = _X[2] + _X[6];\nb4 = _X[5] - _X[3];\ntmp1 = _X[1] + _X[7];\ntmp2 = _X[3] + _X[5];\nb6 = _X[1] - _X[7];\nb7 = tmp1 + tmp2;\nm0 =  _X[0];\nx4 =  ((b6*473 - b4*196 + 128) / 256) - b7;\nx0 =  x4 - (((tmp1 - tmp2)*362 + 128) / 256);\nx1 =  m0 - b1;\nx2 =  (((_X[2] - _X[6])*362 + 128) / 256) - b3;\nx3 =  m0 + b1;\ny3 =  x1 + x2;\ny4 =  x3 + b3;\ny5 =  x1 - x2;\ny6 =  x3 - b3;\ny7 = -x0 - ((b4*473 + b6*196 + 128) / 256);",
SHADER_FRAGMENT_IDCT_ROWS_INTRA_1_INT="if( _A == 0.0 )\n{\ngl_FragColor = vec4(\nfloat( ( b7 + y4 + 128 ) / 256 ) / 255.,\nfloat( ( x4 + y3 + 128 ) / 256 ) / 255.,\nfloat( ( y5 - x0 + 128 ) / 256 ) / 255.,\nfloat( ( y6 - y7 + 128 ) / 256 ) / 255.\n);\n}\nelse\n{\ngl_FragColor = vec4(\nfloat( ( y6 + y7 + 128 ) / 256 ) / 255.,\nfloat( ( x0 + y5 + 128 ) / 256 ) / 255.,\nfloat( ( y3 - x4 + 128 ) / 256 ) / 255.,\nfloat( ( y4 - b7 + 128 ) / 256 ) / 255.\n);\n}\n}",SHADER_FRAGMENT_IDCT_ROWS_INTRA_1_FLOAT=
"if( _A == 0.0 )\n{\ngl_FragColor = vec4(\ndot( _ab( _X, 0.), vec2(1.,256.) ),\ndot( _ab( _X, 1.), vec2(1.,256.) ),\ndot( _ab( _X, 2.), vec2(1.,256.) ),\ndot( _ab( _X, 3.), vec2(1.,256.) )\n);\n}\nelse\n{\ngl_FragColor = vec4(\ndot( _ab( _X, 4.), vec2(1.,256.) ),\ndot( _ab( _X, 5.), vec2(1.,256.) ),\ndot( _ab( _X, 6.), vec2(1.,256.) ),\ndot( _ab( _X, 7.), vec2(1.,256.) )\n);\n}\n}",SHADER_FRAGMENT_IDCT_ROWS_INTER_1="vec4 _C;\nif( _Q < 4. || _R > 3. ){\n}\nif ( texture2D( _w, vec2( ( _Q + .5 ) * _h, 1. - ( _R + .5 ) * _d ) ).r > 0.5 )\n{\n_C = vec4(0.,0.,0.,0.);\n}\nelse\n{\nvec4 _ar = texture2D( _I, vec2( _S.x, 1. - _e * 0.25 - _S.y) );\nfloat _W = _E( _ar.rg );\nfloat _V = _E( _ar.ba );\nfloat _ax, _ay;\nbool odd_h, odd_v;\nif( _ac == 1.){\n_ax = floor( _W / 2. );\n_ay = floor( _V / 2. );\nodd_h = abs(_W - _ax * 2.) > 0.5;\nodd_v = abs(_V - _ay * 2.) > 0.5;\n}else{\n_ax = floor( _F( _W / 2.) / 2. );\n_ay = floor( _F( _V / 2.) / 2. );\nodd_h = ( mod( _F( _W / 2. ), 2. ) != 0.);\nodd_v = ( mod( _F( _V / 2. ), 2. ) != 0.);\n}\n_ay *= -1.;\n_C = _p( _ax, _ay );\nfloat _aa = 1.;\nvec4 _am = vec4( .001953125, .001953125, .001953125, .001953125 );\nif( odd_h ) {\n_C += _p( _ax + 1., _ay ) + _am;\n_aa *= 2.;\n}\nif ( odd_v ) {\n_C += _p( _ax, _ay - 1. ) + _am;\n_aa *= 2.;\n}\nif( odd_h && odd_v ) {\n_C += _p( _ax + 1., _ay - 1. );\n}\n_C /= _aa;\n}",
INTER_INT1="if( _A == 0.0 )\n{\ngl_FragColor = vec4(\n(float( ( b7 + y4 + 128 ) / 256 ) / 255.),\n(float( ( x4 + y3 + 128 ) / 256 ) / 255.),\n(float( ( y5 - x0 + 128 ) / 256 ) / 255.),\n(float( ( y6 - y7 + 128 ) / 256 ) / 255.)\n);\n}\nelse\n{\ngl_FragColor = vec4(\n(float( ( y6 + y7 + 128 ) / 256 ) / 255.),\n(float( ( x0 + y5 + 128 ) / 256 ) / 255.),\n(float( ( y3 - x4 + 128 ) / 256 ) / 255.),\n(float( ( y4 - b7 + 128 ) / 256 ) / 255.)\n);\n}\ngl_FragColor += _C;\n}",INTER_FLOAT1="if( _A == 0.0 )\n{\ngl_FragColor = vec4(\ndot( _ab( _X, 0.), vec2(1.,256.) ),\ndot( _ab( _X, 1.), vec2(1.,256.) ),\ndot( _ab( _X, 2.), vec2(1.,256.) ),\ndot( _ab( _X, 3.), vec2(1.,256.) )\n);\n}\nelse\n{\ngl_FragColor = vec4(\ndot( _ab( _X, 4.), vec2(1.,256.) ),\ndot( _ab( _X, 5.), vec2(1.,256.) ),\ndot( _ab( _X, 6.), vec2(1.,256.) ),\ndot( _ab( _X, 7.), vec2(1.,256.) )\n);\n}\ngl_FragColor += _C;\n}";